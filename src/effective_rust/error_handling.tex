Like most programming languages, Rust encourages the programmer to handle errors in a particular way. Generally speaking, 
error handling is divided into two broad categories: exceptions and return values. Rust opts for return values.

\blank

In this section, we intend to provide a comprehensive treatment of how to deal with errors in Rust. More than that, we will 
attempt to introduce error handling one piece at a time so that you'll come away with a solid working knowledge of how everything 
fits together.

\blank

When done naively, error handling in Rust can be verbose and annoying. This section will explore those stumbling blocks and 
demonstrate how to use the standard library to make error handling concise and ergonomic.

\subsection*{Table of Contents}

This section is very long, mostly because we start at the very beginning with sum types and combinators, and try to motivate 
the way Rust does error handling incrementally. As such, programmers with experience in other expressive type systems may 
want to jump around.
%
%     The Basics
%         Unwrapping explained
%         The Option type
%             Composing Option<T> values
%         The Result type
%             Parsing integers
%             The Result type alias idiom
%         A brief interlude: unwrapping isn't evil
%     Working with multiple error types
%         Composing Option and Result
%         The limits of combinators
%         Early returns
%         The try! macro
%         Defining your own error type
%     Standard library traits used for error handling
%         The Error trait
%         The From trait
%         The real try! macro
%         Composing custom error types
%         Advice for library writers
%     Case study: A program to read population data
%         Initial setup
%         Argument parsing
%         Writing the logic
%         Error handling with Box<Error>
%         Reading from stdin
%         Error handling with a custom type
%         Adding functionality
%     The short story
%
\subsection*{The Basics}

You can think of error handling as using case analysis to determine whether a computation was successful or not. As 
you will see, the key to ergonomic error handling is reducing the amount of explicit case analysis the programmer has 
to do while keeping code composable.

\blank

Keeping code composable is important, because without that requirement, we could 
\href{https://doc.rust-lang.org/std/macro.panic!.html}{panic} whenever we come across something unexpected. (\code{panic} 
causes the current task to unwind, and in most cases, the entire program aborts.) Here's an example:

\begin{rustc}
// Guess a number between 1 and 10.
// If it matches the number we had in mind, return true. Else, return false.
fn guess(n: i32) -> bool {
    if n < 1 || n > 10 {
        panic!("Invalid number: {}", n);
    }
    n == 5
}

fn main() {
    guess(11);
}
\end{rustc}

If you try running this code, the program will crash with a message like this:

\begin{verbatim}
thread '<main>' panicked at 'Invalid number: 11', src/bin/panic-simple.rs:5
\end{verbatim}

Here's another example that is slightly less contrived. A program that accepts an integer as an argument, doubles 
it and prints it.

\begin{rustc}
use std::env;

fn main() {
    let mut argv = env::args();
    let arg: String = argv.nth(1).unwrap(); // error 1
    let n: i32 = arg.parse().unwrap(); // error 2
    println!("{}", 2 * n);
}
\end{rustc}

If you give this program zero arguments (error 1) or if the first argument isn't an integer (error 2), the program will 
panic just like in the first example.

\blank

You can think of this style of error handling as similar to a bull running through a china shop. The bull will get to where 
it wants to go, but it will trample everything in the process.

\subsubsection*{Unwrapping explained}

In the previous example, we claimed that the program would simply panic if it reached one of the two error conditions, 
yet, the program does not include an explicit call to \code{panic} like the first example. This is because the \code{panic} 
is embedded in the calls to \code{unwrap}.

\blank

To \enquote{unwrap} something in Rust is to say, \enquote{Give me the result of the computation, and if there was an error, 
panic and stop the program.} It would be better if we showed the code for unwrapping because it is so simple, but to do that, 
we will first need to explore the \option\ and \result\ types. Both of these types have a method called \code{unwrap} 
defined on them.

\subsubsection*{The \option\ type}

The \option\ type is \href{https://doc.rust-lang.org/std/option/enum.Option.html}{defined in the standard library}:

\begin{rustc}
enum Option<T> {
    None,
    Some(T),
}
\end{rustc}

The \option\ type is a way to use Rust's type system to express the \emph{possibility of absence}. Encoding the 
possibility of absence into the type system is an important concept because it will cause the compiler to force the 
programmer to handle that absence. Let's take a look at an example that tries to find a character in a string:

\begin{rustc}
// Searches `haystack` for the Unicode character `needle`. If one is found, the
// byte offset of the character is returned. Otherwise, `None` is returned.
fn find(haystack: &str, needle: char) -> Option<usize> {
    for (offset, c) in haystack.char_indices() {
        if c == needle {
            return Some(offset);
        }
    }
    None
}
\end{rustc}

Notice that when this function finds a matching character, it doesn't only return the \code{offset}. Instead, it returns 
\code{Some(offset)}. \code{Some} is a variant or a \emph{value constructor} for the \option\ type. You can think of 
it as a function with the type \code{fn<T>(value: T) -> Option<T>}. Correspondingly, \none\ is also a value constructor, 
except it has no arguments. You can think of \none\ as a function with the type \code{fn<T>() -> Option<T>}.

\blank

This might seem like much ado about nothing, but this is only half of the story. The other half is \emph{using} the 
\code{find} function we've written. Let's try to use it to find the extension in a file name.

\begin{rustc}
fn main() {
    let file_name = "foobar.rs";
    match find(file_name, '.') {
        None => println!("No file extension found."),
        Some(i) => println!("File extension: {}", &file_name[i+1..]),
    }
}
\end{rustc}

This code uses pattern matching (see \nameref{sec:syntax_patterns}) to do \emph{case analysis} on the \code{Option<usize>} 
returned by the \code{find} function. In fact, case analysis is the only way to get at the value stored inside an 
\code{Option<T>}. This means that you, as the programmer, must handle the case when an \code{Option<T>} is \none\ 
instead of \code{Some(t)}.

\blank

But wait, what about \code{unwrap}, which we used previously? There was no case analysis there! Instead, the case analysis 
was put inside the \code{unwrap} method for you. You could define it yourself if you want:

\begin{rustc}
enum Option<T> {
    None,
    Some(T),
}

impl<T> Option<T> {
    fn unwrap(self) -> T {
        match self {
            Option::Some(val) => val,
            Option::None =>
              panic!("called `Option::unwrap()` on a `None` value"),
        }
    }
}
\end{rustc}

The \code{unwrap} method \emph{abstracts away the case analysis}. This is precisely the thing that makes \code{unwrap} 
ergonomic to use. Unfortunately, that \panic\ means that \code{unwrap} is not composable: it is the bull in the china shop.

\parag{Composing \code{Option<T>} values}

In an example from before, we saw how to use \code{find} to discover the extension in a file name. Of course, not all file 
names have a \code{.} in them, so it's possible that the file name has no extension. This \emph{possibility of absence} is 
encoded into the types using \code{Option<T>}. In other words, the compiler will force us to address the possibility that 
an extension does not exist. In our case, we only print out a message saying as such.

\blank

Getting the extension of a file name is a pretty common operation, so it makes sense to put it into a function:

\begin{rustc}
// Returns the extension of the given file name, where the extension is defined
// as all characters proceeding the first `.`.
// If `file_name` has no `.`, then `None` is returned.
fn extension_explicit(file_name: &str) -> Option<&str> {
    match find(file_name, '.') {
        None => None,
        Some(i) => Some(&file_name[i+1..]),
    }
}
\end{rustc}

(Pro-tip: don't use this code. Use the \href{https://doc.rust-lang.org/std/path/struct.Path.html#method.extension}{extension} 
method in the standard library instead.)

\blank

The code stays simple, but the important thing to notice is that the type of \code{find} forces us to consider the 
possibility of absence. This is a good thing because it means the compiler won't let us accidentally forget about the 
case where a file name doesn't have an extension. On the other hand, doing explicit case analysis like we've done 
in \code{extension\_explicit} every time can get a bit tiresome.

\blank

In fact, the case analysis in \code{extension\_explicit} follows a very common pattern: \emph{map} a function on to 
the value inside of an \code{Option<T>}, unless the option is \none, in which case, return \none.

\blank

Rust has parametric polymorphism, so it is very easy to define a combinator that abstracts this pattern:

\begin{rustc}
fn map<F, T, A>(option: Option<T>, f: F) -> Option<A> where F: FnOnce(T) -> A {
    match option {
        None => None,
        Some(value) => Some(f(value)),
    }
}
\end{rustc}

Indeed, \code{map} is \href{https://doc.rust-lang.org/std/option/enum.Option.html#method.map}{defined as a method} 
on \code{Option<T>} in the standard library.

\blank

Armed with our new combinator, we can rewrite our \code{extension\_explicit} method to get rid of the case analysis:

\begin{rustc}
// Returns the extension of the given file name, where the extension is defined
// as all characters proceeding the first `.`.
// If `file_name` has no `.`, then `None` is returned.
fn extension(file_name: &str) -> Option<&str> {
    find(file_name, '.').map(|i| &file_name[i+1..])
}
\end{rustc}

One other pattern we commonly find is assigning a default value to the case when an \option\ value is \none. 
For example, maybe your program assumes that the extension of a file is \code{rs} even if none is present. As you might 
imagine, the case analysis for this is not specific to file extensions - it can work with any \code{Option<T>}:

\begin{rustc}
fn unwrap_or<T>(option: Option<T>, default: T) -> T {
    match option {
        None => default,
        Some(value) => value,
    }
}
\end{rustc}

The trick here is that the default value must have the same type as the value that might be inside the \code{Option<T>}. 
Using it is dead simple in our case:

\begin{rustc}
fn main() {
    assert_eq!(extension("foobar.csv").unwrap_or("rs"), "csv");
    assert_eq!(extension("foobar").unwrap_or("rs"), "rs");
}
\end{rustc}

(Note that \code{unwrap\_or} is \href{https://doc.rust-lang.org/std/option/enum.Option.html\#method.unwrap\_or}{defined as a method} 
on \code{Option<T>} in the standard library, so we use that here instead of the free-standing function we defined above. 
Don't forget to check out the more general 
\href{https://doc.rust-lang.org/std/option/enum.Option.html\#method.unwrap\_or\_else}{unwrap\_or\_else method}.)

\blank

There is one more combinator that we think is worth paying special attention to: \code{and\_then}. It makes it easy to 
compose distinct computations that admit the \emph{possibility of absence}. For example, much of the code in this section 
is about finding an extension given a file name. In order to do this, you first need the file name which is typically 
extracted from a file path. While most file paths have a file name, not all of them do. For example, \code{.}, \code{..} or 
\code{/}.

\blank

So, we are tasked with the challenge of finding an extension given a file path. Let's start with explicit case analysis:

\begin{rustc}
fn file_path_ext_explicit(file_path: &str) -> Option<&str> {
    match file_name(file_path) {
        None => None,
        Some(name) => match extension(name) {
            None => None,
            Some(ext) => Some(ext),
        }
    }
}

fn file_name(file_path: &str) -> Option<&str> {
  // implementation elided
  unimplemented!()
}
\end{rustc}

You might think that we could use the \code{map} combinator to reduce the case analysis, but its type doesn't quite fit. 
Namely, \code{map} takes a function that does something only with the inner value. The result of that function is then 
\emph{always} rewrapped with \code{Some}. Instead, we need something like \code{map}, but which allows the caller to 
return another \option. Its generic implementation is even simpler than \code{map}:

\begin{rustc}
fn and_then<F, T, A>(option: Option<T>, f: F) -> Option<A>
        where F: FnOnce(T) -> Option<A> {
    match option {
        None => None,
        Some(value) => f(value),
    }
}
\end{rustc}

Now we can rewrite our \code{file\_path\_ext} function without explicit case analysis:

\begin{rustc}
fn file_path_ext(file_path: &str) -> Option<&str> {
    file_name(file_path).and_then(extension)
}
\end{rustc}

The \option\ type has many other combinators \href{https://doc.rust-lang.org/std/option/enum.Option.html}{defined in 
the standard library}. It is a good idea to skim this list and familiarize yourself with what's availableâ€”they can often 
reduce case analysis for you. Familiarizing yourself with these combinators will pay dividends because many of them are also 
defined (with similar semantics) for \result, which we will talk about next.

\blank

Combinators make using types like \option\ ergonomic because they reduce explicit case analysis. They are also 
composable because they permit the caller to handle the possibility of absence in their own way. Methods like \code{unwrap} 
remove choices because they will panic if \code{Option<T>} is \none.

\subsubsection*{The \result\ type}

The \result\ type is also \href{https://doc.rust-lang.org/std/result/}{defined in the standard library}:

\begin{rustc}
enum Result<T, E> {
    Ok(T),
    Err(E),
}
\end{rustc}

The \result\ type is a richer version of \option. Instead of expressing the \emph{possibility of absence} like 
\option\ does, \result\ expresses the \emph{possibility of error}. Usually, the error is used to explain why the 
execution of some computation failed. This is a strictly more general form of \option. Consider the following type 
alias, which is semantically equivalent to the real \code{Option<T}> in every way:

\begin{rustc}
type Option<T> = Result<T, ()>;
\end{rustc}

This fixes the second type parameter of \result\ to always be \code{()} (pronounced \enquote{unit} or \enquote{empty 
tuple}). Exactly one value inhabits the \code{()} type: \code{()}. (Yup, the type and value level terms have the same notation!)

\blank

The \result\ type is a way of representing one of two possible outcomes in a computation. By convention, one outcome is 
meant to be expected or \enquote{\code{Ok}} while the other outcome is meant to be unexpected or \enquote{\code{Err}}.

\blank

Just like \option, the \result\ type also has an 
\href{https://doc.rust-lang.org/std/result/enum.Result.html\#method.unwrap}{unwrap method defined} in the standard library. 
Let's define it:

\begin{rustc}
impl<T, E: ::std::fmt::Debug> Result<T, E> {
    fn unwrap(self) -> T {
        match self {
            Result::Ok(val) => val,
            Result::Err(err) =>
              panic!("called `Result::unwrap()` on an `Err` value: {:?}", err),
        }
    }
}
\end{rustc}

This is effectively the same as our definition for \code{Option::unwrap}, except it includes the error value in the \panic\ 
message. This makes debugging easier, but it also requires us to add a 
\href{https://doc.rust-lang.org/std/fmt/trait.Debug.html}{Debug} constraint on the \code{E} type parameter (which represents 
our error type). Since the vast majority of types should satisfy the \code{Debug} constraint, this tends to work out in 
practice. (\code{Debug} on a type simply means that there's a reasonable way to print a human readable description of values 
with that type.)

\blank

OK, let's move on to an example.

\parag{Parsing integers}

The Rust standard library makes converting strings to integers dead simple. It's so easy in fact, that it is very tempting 
to write something like the following:

\begin{rustc}
fn double_number(number_str: &str) -> i32 {
    2 * number_str.parse::<i32>().unwrap()
}

fn main() {
    let n: i32 = double_number("10");
    assert_eq!(n, 20);
}
\end{rustc}

At this point, you should be skeptical of calling \code{unwrap}. For example, if the string doesn't parse as a number, 
you'll get a panic:

\begin{verbatim}
thread '<main>' panicked at 'called `Result::unwrap()` on an `Err` value: ParseIntError { kind: InvalidDigit }', /home/rustbuild/src/rust-buildbot/slave/beta-dist-rustc-linux/build/src/libcore/result.rs:729
\end{verbatim}

This is rather unsightly, and if this happened inside a library you're using, you might be understandably annoyed. Instead, 
we should try to handle the error in our function and let the caller decide what to do. This means changing the return type 
of \code{double\_number}. But to what? Well, that requires looking at the signature of the \code{parse} method in the 
\href{https://doc.rust-lang.org/std/primitive.str.html\#method.parse}{standard library}:

\begin{rustc}
impl str {
    fn parse<F: FromStr>(&self) -> Result<F, F::Err>;
}
\end{rustc}

Hmm. So we at least know that we need to use a \result. Certainly, it's possible that this could have returned an 
\option. After all, a string either parses as a number or it doesn't, right? That's certainly a reasonable way to go, 
but the implementation internally distinguishes why the string didn't parse as an integer. (Whether it's an empty string, an 
invalid digit, too big or too small.) Therefore, using a \result\ makes sense because we want to provide more information 
than simply \enquote{absence.} We want to say why the parsing failed. You should try to emulate this line of reasoning when 
faced with a choice between \option\ and \result. If you can provide detailed error information, then you probably 
should. (We'll see more on this later.)

\blank

OK, but how do we write our return type? The \code{parse} method as defined above is generic over all the different number 
types defined in the standard library. We could (and probably should) also make our function generic, but let's favor 
explicitness for the moment. We only care about \itt, so we need to 
\href{https://doc.rust-lang.org/std/primitive.i32.html}{find its implementation of FromStr} (do a \code{CTRL-F} in your 
browser for \enquote{FromStr}) and look at its associated type \code{Err}. We did this so we can find the concrete error type. 
In this case, it's \href{https://doc.rust-lang.org/std/num/struct.ParseIntError.html}{std::num::ParseIntError}. Finally, 
we can rewrite our function:

\begin{rustc}
use std::num::ParseIntError;

fn double_number(number_str: &str) -> Result<i32, ParseIntError> {
    match number_str.parse::<i32>() {
        Ok(n) => Ok(2 * n),
        Err(err) => Err(err),
    }
}

fn main() {
    match double_number("10") {
        Ok(n) => assert_eq!(n, 20),
        Err(err) => println!("Error: {:?}", err),
    }
}
\end{rustc}

This is a little better, but now we've written a lot more code! The case analysis has once again bitten us.

\blank

Combinators to the rescue! Just like \option, \result\ has lots of combinators defined as methods. There is 
a large intersection of common combinators between \result\ and \option. In particular, map is part of that 
intersection:

\begin{rustc}
use std::num::ParseIntError;

fn double_number(number_str: &str) -> Result<i32, ParseIntError> {
    number_str.parse::<i32>().map(|n| 2 * n)
}

fn main() {
    match double_number("10") {
        Ok(n) => assert_eq!(n, 20),
        Err(err) => println!("Error: {:?}", err),
    }
}
\end{rustc}

The usual suspects are all there for \result, including 
\href{https://doc.rust-lang.org/std/result/enum.Result.html\#method.unwrap\_or}{unwrap\_or} and 
\href{https://doc.rust-lang.org/std/result/enum.Result.html\#method.and\_then}{and\_then}. Additionally, since \result\ 
has a second type parameter, there are combinators that affect only the error type, such as 
\href{https://doc.rust-lang.org/std/result/enum.Result.html\#method.map\_err}{map\_err} (instead of \code{map}) and 
\href{https://doc.rust-lang.org/std/result/enum.Result.html\#method.or\_else}{or\_else} (instead of \code{and\_then}).

\parag{The \result\ type alias idiom}

In the standard library, you may frequently see types like \code{Result<i32>}. But wait, we defined \result\ to have 
two type parameters. How can we get away with only specifying one? The key is to define a \result\ type alias that 
fixes one of the type parameters to a particular type. Usually the fixed type is the error type. For example, our previous 
example parsing integers could be rewritten like this:

\begin{rustc}
use std::num::ParseIntError;
use std::result;

type Result<T> = result::Result<T, ParseIntError>;

fn double_number(number_str: &str) -> Result<i32> {
    unimplemented!();
}
\end{rustc}

Why would we do this? Well, if we have a lot of functions that could return \code{ParseIntError}, then it's much more 
convenient to define an alias that always uses \code{ParseIntError} so that we don't have to write it out all the time.

\blank

The most prominent place this idiom is used in the standard library is with 
\href{https://doc.rust-lang.org/std/io/type.Result.html}{io::Result}. Typically, one writes \code{io::Result<T>}, which 
makes it clear that you're using the \code{io} module's type alias instead of the plain definition from \code{std::result}. 
(This idiom is also used for \href{https://doc.rust-lang.org/std/fmt/type.Result.html}{fmt::Result}.)

\subsubsection*{A brief interlude: unwrapping isn't evil}

If you've been following along, you might have noticed that I've taken a pretty hard line against calling methods like 
\code{unwrap} that could \code{panic} and abort your program. \emph{Generally speaking}, this is good advice.

\blank

However, \code{unwrap} can still be used judiciously. What exactly justifies use of \code{unwrap} is somewhat of a grey 
area and reasonable people can disagree. I'll summarize some of my \emph{opinions} on the matter.

\begin{itemize}
  \item{\textbf{In examples and quick 'n' dirty code.} Sometimes you're writing examples or a quick program, and error 
      handling simply isn't important. Beating the convenience of \code{unwrap} can be hard in such scenarios, so it is 
      very appealing.}
  \item{\textbf{When panicking indicates a bug in the program.} When the invariants of your code should prevent a certain 
      case from happening (like, say, popping from an empty stack), then panicking can be permissible. This is because it 
      exposes a bug in your program. This can be explicit, like from an \code{assert!} failing, or it could be because your 
      index into an array was out of bounds.}
\end{itemize}

This is probably not an exhaustive list. Moreover, when using an \option, it is often better to use its 
\href{https://doc.rust-lang.org/std/option/enum.Option.html\#method.expect}{expect} method. \code{expect} does exactly the 
same thing as \code{unwrap}, except it prints a message you give to \code{expect}. This makes the resulting panic a bit nicer 
to deal with, since it will show your message instead of \enquote{called \code{unwrap} on a \none\ value.}

\blank

My advice boils down to this: use good judgment. There's a reason why the words \enquote{never do X} or \enquote{Y is 
considered harmful} don't appear in my writing. There are trade offs to all things, and it is up to you as the programmer 
to determine what is acceptable for your use cases. My goal is only to help you evaluate trade offs as accurately as possible.

\blank

Now that we've covered the basics of error handling in Rust, and explained unwrapping, let's start exploring more of the 
standard library.

\subsection*{Working with multiple error types}

Thus far, we've looked at error handling where everything was either an \code{Option<T>} or a \code{Result<T, SomeError>}. 
But what happens when you have both an \option\ and a \result? Or what if you have a \code{Result<T, Error1>} 
and a \code{Result<T, Error2>}? Handling composition of distinct error types is the next challenge in front of us, and it 
will be the major theme throughout the rest of this section.

\subsubsection*{Composing \option\ and \result}

So far, I've talked about combinators defined for \option\ and combinators defined for \result. We can use 
these combinators to compose results of different computations without doing explicit case analysis.

\blank

Of course, in real code, things aren't always as clean. Sometimes you have a mix of \option\ and \result\ types. 
Must we resort to explicit case analysis, or can we continue using combinators?

\blank

For now, let's revisit one of the first examples in this section:

\begin{rustc}
use std::env;

fn main() {
    let mut argv = env::args();
    let arg: String = argv.nth(1).unwrap(); // error 1
    let n: i32 = arg.parse().unwrap(); // error 2
    println!("{}", 2 * n);
}
\end{rustc}

Given our new found knowledge of \option, \result\ and their various combinators, we should try to rewrite this so that 
errors are handled properly and the program doesn't panic if there's an error.

\blank

The tricky aspect here is that \code{argv.nth(1)} produces an \option\ while \code{arg.parse()} produces a \result. These 
aren't directly composable. When faced with both an \option\ and a \result, the solution is usually to convert the \option\ 
to a \result. In our case, the absence of a command line parameter (from \code{env::args()}) means the user didn't invoke 
the program correctly. We could use a \String\ to describe the error. Let's try:

\begin{rustc}
use std::env;

fn double_arg(mut argv: env::Args) -> Result<i32, String> {
    argv.nth(1)
        .ok_or("Please give at least one argument".to_owned())
        .and_then(|arg| arg.parse::<i32>().map_err(|err| err.to_string()))
        .map(|n| 2 * n)
}

fn main() {
    match double_arg(env::args()) {
        Ok(n) => println!("{}", n),
        Err(err) => println!("Error: {}", err),
    }
}
\end{rustc}

There are a couple new things in this example. The first is the use of the 
\href{https://doc.rust-lang.org/std/option/enum.Option.html\#method.ok\_or}{Option::ok\_or} combinator. This is one way to 
convert an \option\ into a \result. The conversion requires you to specify what error to use if \option\ is \none. Like 
the other combinators we've seen, its definition is very simple:

\begin{rustc}
fn ok_or<T, E>(option: Option<T>, err: E) -> Result<T, E> {
    match option {
        Some(val) => Ok(val),
        None => Err(err),
    }
}
\end{rustc}

The other new combinator used here is \href{https://doc.rust-lang.org/std/result/enum.Result.html\#method.map\_err}
{Result::map\_err}. This is like \code{Result::map}, except it maps a function on to the error portion of a \result\ value. 
If the \result\ is an \code{Ok(...)} value, then it is returned unmodified.

\blank

We use \code{map\_err} here because it is necessary for the error types to remain the same (because of our use of 
\code{and\_then}). Since we chose to convert the \code{Option<String>} (from \code{argv.nth(1)}) to a \code{Result<String, String>},
we must also convert the \code{ParseIntError} from \code{arg.parse()} to a \String.

\subsubsection*{The limits of combinators}

Doing IO and parsing input is a very common task, and it's one that I personally have done a lot of in Rust. Therefore, we 
will use (and continue to use) IO and various parsing routines to exemplify error handling.

\blank

Let's start simple. We are tasked with opening a file, reading all of its contents and converting its contents to a number. 
Then we multiply it by \code{2} and print the output.

\blank

Although I've tried to convince you not to use \code{unwrap}, it can be useful to first write your code using \code{unwrap}. 
It allows you to focus on your problem instead of the error handling, and it exposes the points where proper error handling 
need to occur. Let's start there so we can get a handle on the code, and then refactor it to use better error handling.

\begin{rustc}
use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double<P: AsRef<Path>>(file_path: P) -> i32 {
    let mut file = File::open(file_path).unwrap(); // error 1
    let mut contents = String::new();
    file.read_to_string(&mut contents).unwrap(); // error 2
    let n: i32 = contents.trim().parse().unwrap(); // error 3
    2 * n
}

fn main() {
    let doubled = file_double("foobar");
    println!("{}", doubled);
}
\end{rustc}

(N.B. The \code{AsRef<Path>} is used because those are the 
\href{https://doc.rust-lang.org/std/fs/struct.File.html\#method.open}{same bounds used on std::fs::File::open}. This makes 
it ergonomic to use any kind of string as a file path.)

\blank

There are three different errors that can occur here:

\begin{enumerate}
  \item{A problem opening the file.}
  \item{A problem reading data from the file.}
  \item{A problem parsing the data as a number.}
\end{enumerate}

The first two problems are described via the \href{https://doc.rust-lang.org/std/io/struct.Error.html}{std::io::Error} type. 
We know this because of the return types of 
\href{https://doc.rust-lang.org/std/fs/struct.File.html\#method.open}{std::fs::File::open} and 
\href{https://doc.rust-lang.org/std/io/trait.Read.html\#method.read\_to\_string}{std::io::Read::read\_to\_string}. (Note that 
they both use the \result\ type alias idiom described previously. If you click on the \result\ type, you'll 
\href{https://doc.rust-lang.org/std/io/type.Result.html}{see the type alias}, and consequently, the underlying \code{io::Error} 
type.) The third problem is described by the 
\href{https://doc.rust-lang.org/std/num/struct.ParseIntError.html}{std::num::ParseIntError} type. The \code{io::Error} type 
in particular is \emph{pervasive} throughout the standard library. You will see it again and again.

\blank

Let's start the process of refactoring the \code{file\_double} function. To make this function composable with other 
components of the program, it should not panic if any of the above error conditions are met. Effectively, this means t
hat the function should \emph{return an error} if any of its operations fail. Our problem is that the return type of 
\code{file\_double} is \itt, which does not give us any useful way of reporting an error. Thus, we must start by changing 
the return type from \itt\ to something else.

\blank

The first thing we need to decide: should we use \option\ or \result? We certainly could use \option\ very easily. If any 
of the three errors occur, we could simply return \none. This will work and it is better than panicking, but we can do a 
lot better. Instead, we should pass some detail about the error that occurred. Since we want to express the possibility of 
error, we should use \code{Result<i32, E>}. But what should \code{E} be? Since two different types of errors can occur, we 
need to convert them to a common type. One such type is \String. Let's see how that impacts our code:

\begin{rustc}
use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double<P: AsRef<Path>>(file_path: P) -> Result<i32, String> {
    File::open(file_path)
         .map_err(|err| err.to_string())
         .and_then(|mut file| {
              let mut contents = String::new();
              file.read_to_string(&mut contents)
                  .map_err(|err| err.to_string())
                  .map(|_| contents)
         })
         .and_then(|contents| {
              contents.trim().parse::<i32>()
                      .map_err(|err| err.to_string())
         })
         .map(|n| 2 * n)
}

fn main() {
    match file_double("foobar") {
        Ok(n) => println!("{}", n),
        Err(err) => println!("Error: {}", err),
    }
}
\end{rustc}

This code looks a bit hairy. It can take quite a bit of practice before code like this becomes easy to write. The way we 
write it is by following the types. As soon as we changed the return type of \code{file\_double} to \code{Result<i32, String>}, 
we had to start looking for the right combinators. In this case, we only used three different combinators: 
\code{and\_then}, \code{map} and \code{map\_err}.

\blank

\code{and\_then} is used to chain multiple computations where each computation could return an error. After opening the file, 
there are two more computations that could fail: reading from the file and parsing the contents as a number. Correspondingly, 
there are two calls to \code{and\_then}.

\blank

\code{map} is used to apply a function to the \code{Ok(...)} value of a \result. For example, the very last call to \code{map}
multiplies the \code{Ok(...)} value (which is an \itt) by \code{2}. If an error had occurred before that point, this operation 
would have been skipped because of how \code{map} is defined.

\blank

\code{map\_err} is the trick that makes all of this work. \code{map\_err} is like \code{map}, except it applies a function to 
the \code{Err(...)} value of a \result. In this case, we want to convert all of our errors to one type: \String. Since both 
\code{io::Error} and \code{num::ParseIntError} implement \code{ToString}, we can call the \code{to\_string()} method to 
convert them.

\blank

With all of that said, the code is still hairy. Mastering use of combinators is important, but they have their limits. 
Let's try a different approach: early returns.

\subsubsection*{Early returns}

I'd like to take the code from the previous section and rewrite it using \emph{early returns}. Early returns let you exit 
the function early. We can't return early in \code{file\_double} from inside another closure, so we'll need to revert back 
to explicit case analysis.

\begin{rustc}
use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double<P: AsRef<Path>>(file_path: P) -> Result<i32, String> {
    let mut file = match File::open(file_path) {
        Ok(file) => file,
        Err(err) => return Err(err.to_string()),
    };
    let mut contents = String::new();
    if let Err(err) = file.read_to_string(&mut contents) {
        return Err(err.to_string());
    }
    let n: i32 = match contents.trim().parse() {
        Ok(n) => n,
        Err(err) => return Err(err.to_string()),
    };
    Ok(2 * n)
}

fn main() {
    match file_double("foobar") {
        Ok(n) => println!("{}", n),
        Err(err) => println!("Error: {}", err),
    }
}
\end{rustc}

Reasonable people can disagree over whether this code is better than the code that uses combinators, but if you aren't 
familiar with the combinator approach, this code looks simpler to read to me. It uses explicit case analysis with \code{match} 
and \code{if let}. If an error occurs, it simply stops executing the function and returns the error (by converting it to a 
string).

\blank

Isn't this a step backwards though? Previously, we said that the key to ergonomic error handling is reducing explicit case 
analysis, yet we've reverted back to explicit case analysis here. It turns out, there are \emph{multiple} ways to reduce 
explicit case analysis. Combinators aren't the only way.

\subsubsection*{The \code{try!} macro}

A cornerstone of error handling in Rust is the \code{try!} macro. The \code{try!} macro abstracts case analysis like 
combinators, but unlike combinators, it also abstracts control flow. Namely, it can abstract the \emph{early return 
pattern} seen above.

\blank

Here is a simplified definition of a \code{try!} macro:

\begin{rustc}
macro_rules! try {
    ($e:expr) => (match $e {
        Ok(val) => val,
        Err(err) => return Err(err),
    });
}
\end{rustc}

(The \href{https://doc.rust-lang.org/std/macro.try!.html}{real definition} is a bit more sophisticated. We will address 
that later.)

\blank

Using the \code{try!} macro makes it very easy to simplify our last example. Since it does the case analysis and the early 
return for us, we get tighter code that is easier to read:

\begin{rustc}
use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double<P: AsRef<Path>>(file_path: P) -> Result<i32, String> {
    let mut file = try!(File::open(file_path).map_err(|e| e.to_string()));
    let mut contents = String::new();
    try!(file.read_to_string(&mut contents).map_err(|e| e.to_string()));
    let n = try!(contents.trim().parse::<i32>().map_err(|e| e.to_string()));
    Ok(2 * n)
}

fn main() {
    match file_double("foobar") {
        Ok(n) => println!("{}", n),
        Err(err) => println!("Error: {}", err),
    }
}
\end{rustc}

The \code{map\_err} calls are still necessary given our definition of \code{try!}. This is because the error types still 
need to be converted to \String. The good news is that we will soon learn how to remove those \code{map\_err} calls! The bad 
news is that we will need to learn a bit more about a couple important traits in the standard library before we can remove 
the \code{map\_err} calls.

\subsubsection*{Defining your own error type}

Before we dive into some of the standard library error traits, I'd like to wrap up this section by removing the use of \String\ 
as our error type in the previous examples.

\blank

Using \String\ as we did in our previous examples is convenient because it's easy to convert errors to strings, or even make 
up your own errors as strings on the spot. However, using \String\ for your errors has some downsides.

\blank

The first downside is that the error messages tend to clutter your code. It's possible to define the error messages elsewhere, 
but unless you're unusually disciplined, it is very tempting to embed the error message into your code. Indeed, we did exactly 
this in a previous example.

\blank

The second and more important downside is that \String s are \emph{lossy}. That is, if all errors are converted to strings, 
then the errors we pass to the caller become completely opaque. The only reasonable thing the caller can do with a \String\ 
error is show it to the user. Certainly, inspecting the string to determine the type of error is not robust. (Admittedly, 
this downside is far more important inside of a library as opposed to, say, an application.)

\blank

For example, the \code{io::Error} type embeds an \href{https://doc.rust-lang.org/std/io/enum.ErrorKind.html}{io::ErrorKind}, 
which is structured data that represents what went wrong during an IO operation. This is important because you might want to 
react differently depending on the error. (e.g., A \code{BrokenPipe} error might mean quitting your program gracefully while 
a \code{NotFound} error might mean exiting with an error code and showing an error to the user.) With \code{io::ErrorKind}, 
the caller can examine the type of an error with case analysis, which is strictly superior to trying to tease out the details 
of an error inside of a \String.

\blank

Instead of using a \String\ as an error type in our previous example of reading an integer from a file, we can define our 
own error type that represents errors with \emph{structured data}. We endeavor to not drop information from underlying errors 
in case the caller wants to inspect the details.

\blank

The ideal way to represent \emph{one of many possibilities} is to define our own sum type using \enum. In our case, an error 
is either an \code{io::Error} or a \code{num::ParseIntError}, so a natural definition arises:

\begin{rustc}
use std::io;
use std::num;

// We derive `Debug` because all types should probably derive `Debug`.
// This gives us a reasonable human readable description of `CliError` values.
#[derive(Debug)]
enum CliError {
    Io(io::Error),
    Parse(num::ParseIntError),
}
\end{rustc}

Tweaking our code is very easy. Instead of converting errors to strings, we simply convert them to our \code{CliError} type 
using the corresponding value constructor:

\begin{rustc}
use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double<P: AsRef<Path>>(file_path: P) -> Result<i32, CliError> {
    let mut file = try!(File::open(file_path).map_err(CliError::Io));
    let mut contents = String::new();
    try!(file.read_to_string(&mut contents).map_err(CliError::Io));
    let n: i32 = try!(contents.trim().parse().map_err(CliError::Parse));
    Ok(2 * n)
}

fn main() {
    match file_double("foobar") {
        Ok(n) => println!("{}", n),
        Err(err) => println!("Error: {:?}", err),
    }
}
\end{rustc}

The only change here is switching \code{map\_err(|e| e.to\_string())} (which converts errors to strings) to 
\code{map\_err(CliError::Io)} or \code{map\_err(CliError::Parse)}. The caller gets to decide the level of detail to report 
to the user. In effect, using a \String\ as an error type removes choices from the caller while using a custom \enum\ error 
type like \code{CliError} gives the caller all of the conveniences as before in addition to structured data describing the 
error.

\blank

A rule of thumb is to define your own error type, but a \String\ error type will do in a pinch, particularly if you're 
writing an application. If you're writing a library, defining your own error type should be strongly preferred so that 
you don't remove choices from the caller unnecessarily.

\subsection*{Standard library traits used for error handling}

The standard library defines two integral traits for error handling: 
\href{https://doc.rust-lang.org/std/error/trait.Error.html}{std::error::Error} and 
\href{https://doc.rust-lang.org/std/convert/trait.From.html}{std::convert::From}. While \code{Error} is designed 
specifically for generically describing errors, the \code{From} trait serves a more general role for converting values 
between two distinct types.

\subsubsection*{The \code{Error} trait}

The \code{Error} trait is \href{https://doc.rust-lang.org/std/error/trait.Error.html}{defined in the standard library}:

\begin{rustc}
use std::fmt::{Debug, Display};

trait Error: Debug + Display {
  /// A short description of the error.
  fn description(&self) -> &str;

  /// The lower level cause of this error, if any.
  fn cause(&self) -> Option<&Error> { None }
}
\end{rustc}

This trait is super generic because it is meant to be implemented for all types that represent errors. This will prove 
useful for writing composable code as we'll see later. Otherwise, the trait allows you to do at least the following things:

\begin{itemize}
  \item{Obtain a \code{Debug} representation of the error.}
  \item{Obtain a user-facing \code{Display} representation of the error.}
  \item{Obtain a short description of the error (via the \code{description} method).}
  \item{Inspect the causal chain of an error, if one exists (via the \code{cause} method).}
\end{itemize}

The first two are a result of \code{Error} requiring \code{impl}s for both \code{Debug} and \code{Display}. The latter two 
are from the two methods defined on \code{Error}. The power of \code{Error} comes from the fact that all error types impl
\code{Error}, which means errors can be existentially quantified as a trait object (see \nameref{sec:syntax_traitObjects}). 
This manifests as either \code{Box<Error>} or \code{\&Error}. Indeed, the cause method returns an \code{\&Error}, which is 
itself a trait object. We'll revisit the \code{Error} trait's utility as a trait object later.

\blank

For now, it suffices to show an example implementing the \code{Error} trait. Let's use the error type we defined in the 
previous section:

\begin{rustc}
use std::io;
use std::num;

// We derive `Debug` because all types should probably derive `Debug`.
// This gives us a reasonable human readable description of `CliError` values.
#[derive(Debug)]
enum CliError {
    Io(io::Error),
    Parse(num::ParseIntError),
}
\end{rustc}

This particular error type represents the possibility of two types of errors occurring: an error dealing with I/O or an 
error converting a string to a number. The error could represent as many error types as you want by adding new variants to 
the \enum\ definition.

\blank

Implementing \code{Error} is pretty straight-forward. It's mostly going to be a lot explicit case analysis.

\begin{rustc}
use std::error;
use std::fmt;

impl fmt::Display for CliError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match *self {
            // Both underlying errors already impl `Display`, so we defer to
            // their implementations.
            CliError::Io(ref err) => write!(f, "IO error: {}", err),
            CliError::Parse(ref err) => write!(f, "Parse error: {}", err),
        }
    }
}

impl error::Error for CliError {
    fn description(&self) -> &str {
        // Both underlying errors already impl `Error`, so we defer to their
        // implementations.
        match *self {
            CliError::Io(ref err) => err.description(),
            CliError::Parse(ref err) => err.description(),
        }
    }

    fn cause(&self) -> Option<&error::Error> {
        match *self {
            // N.B. Both of these implicitly cast `err` from their concrete
            // types (either `&io::Error` or `&num::ParseIntError`)
            // to a trait object `&Error`. This works because both error types
            // implement `Error`.
            CliError::Io(ref err) => Some(err),
            CliError::Parse(ref err) => Some(err),
        }
    }
}
\end{rustc}

We note that this is a very typical implementation of \code{Error}: match on your different error types and satisfy the 
contracts defined for \code{description} and \code{cause}.

\subsubsection*{The \code{From} trait}

The \code{std::convert::From} trait is \href{https://doc.rust-lang.org/std/convert/trait.From.html}{defined in the 
standard library}:

\begin{rustc}
trait From<T> {
    fn from(T) -> Self;
}
\end{rustc}

Deliciously simple, yes? \code{From} is very useful because it gives us a generic way to talk about conversion from a 
particular type \code{T} to some other type (in this case, \enquote{some other type} is the subject of the impl, or 
\code{Self}). The crux of \code{From} is the \href{https://doc.rust-lang.org/std/convert/trait.From.html}{set of 
implementations provided by the standard library}.

\blank

Here are a few simple examples demonstrating how \code{From} works:

\begin{rustc}
let string: String = From::from("foo");
let bytes: Vec<u8> = From::from("foo");
let cow: ::std::borrow::Cow<str> = From::from("foo");
\end{rustc}

OK, so \code{From} is useful for converting between strings. But what about errors? It turns out, there is one critical impl:

\begin{rustc}
impl<'a, E: Error + 'a> From<E> for Box<Error + 'a>
\end{rustc}

This impl says that for \emph{any} type that impls \code{Error}, we can convert it to a trait object \code{Box<Error>}. This 
may not seem terribly surprising, but it is useful in a generic context.

\blank

Remember the two errors we were dealing with previously? Specifically, \code{io::Error} and \code{num::ParseIntError}. Since 
both impl \code{Error}, they work with \code{From}:

\begin{rustc}
use std::error::Error;
use std::fs;
use std::io;
use std::num;

// We have to jump through some hoops to actually get error values.
let io_err: io::Error = io::Error::last_os_error();
let parse_err: num::ParseIntError = "not a number".parse::<i32>().unwrap_err();

// OK, here are the conversions.
let err1: Box<Error> = From::from(io_err);
let err2: Box<Error> = From::from(parse_err);
\end{rustc}

There is a really important pattern to recognize here. Both \code{err1} and \code{err2} have the same type. This is because 
they are existentially quantified types, or trait objects. In particular, their underlying type is erased from the 
compiler's knowledge, so it truly sees \code{err1} and \code{err2} as exactly the same. Additionally, we constructed \code{err1} 
and \code{err2} using precisely the same function call: \code{From::from}. This is because \code{From::from} is overloaded 
on both its argument and its return type.

\blank

This pattern is important because it solves a problem we had earlier: it gives us a way to reliably convert errors to the 
same type using the same function.

\blank

Time to revisit an old friend; the \code{try!} macro.

\subsubsection*{The real \code{try!} macro}

Previously, we presented this definition of \code{try!}:

\begin{rustc}
macro_rules! try {
    ($e:expr) => (match $e {
        Ok(val) => val,
        Err(err) => return Err(err),
    });
}
\end{rustc}

This is not its real definition. Its real definition is \href{https://doc.rust-lang.org/std/macro.try!.html}{in the 
standard library}:

\begin{rustc}
macro_rules! try {
    ($e:expr) => (match $e {
        Ok(val) => val,
        Err(err) => return Err(::std::convert::From::from(err)),
    });
}
\end{rustc}

There's one tiny but powerful change: the error value is passed through \code{From::from}. This makes the \code{try!} macro 
a lot more powerful because it gives you automatic type conversion for free.

\blank

Armed with our more powerful \code{try!} macro, let's take a look at code we wrote previously to read a file and convert 
its contents to an integer:

\begin{rustc}
use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double<P: AsRef<Path>>(file_path: P) -> Result<i32, String> {
    let mut file = try!(File::open(file_path).map_err(|e| e.to_string()));
    let mut contents = String::new();
    try!(file.read_to_string(&mut contents).map_err(|e| e.to_string()));
    let n = try!(contents.trim().parse::<i32>().map_err(|e| e.to_string()));
    Ok(2 * n)
}
\end{rustc}

Earlier, we promised that we could get rid of the \code{map\_err} calls. Indeed, all we have to do is pick a type that 
\code{From} works with. As we saw in the previous section, \code{From} has an impl that lets it convert any error type into 
a \code{Box<Error>}:

\begin{rustc}
use std::error::Error;
use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double<P: AsRef<Path>>(file_path: P) -> Result<i32, Box<Error>> {
    let mut file = try!(File::open(file_path));
    let mut contents = String::new();
    try!(file.read_to_string(&mut contents));
    let n = try!(contents.trim().parse::<i32>());
    Ok(2 * n)
}
\end{rustc}

We are getting very close to ideal error handling. Our code has very little overhead as a result from error handling because 
the \code{try!} macro encapsulates three things simultaneously:

\begin{enumerate}
  \item{Case analysis.}
  \item{Control flow.}
  \item{Error type conversion.}
\end{enumerate}

When all three things are combined, we get code that is unencumbered by combinators, calls to \code{unwrap} or case analysis.

\blank

There's one little nit left: the \code{Box<Error>} type is \emph{opaque}. If we return a \code{Box<Error>} to the caller, 
the caller can't (easily) inspect underlying error type. The situation is certainly better than \String\ because the caller 
can call methods like 
\href{https://doc.rust-lang.org/std/error/trait.Error.html\#tymethod.description}{description} and 
\href{https://doc.rust-lang.org/std/error/trait.Error.html\#method.cause}{cause}, but the limitation remains: \code{Box<Error>} 
is opaque. (N.B. This isn't entirely true because Rust does have runtime reflection, which is useful in some scenarios that are
\href{https://crates.io/crates/error}{beyond the scope of this section}.)

\blank

It's time to revisit our custom \code{CliError} type and tie everything together.

\subsubsection*{Composing custom error types}

In the last section, we looked at the real \code{try!} macro and how it does automatic type conversion for us by calling 
\code{From::from} on the error value. In particular, we converted errors to \code{Box<Error>}, which works, but the type 
is opaque to callers.

\blank

To fix this, we use the same remedy that we're already familiar with: a custom error type. Once again, here is the code 
that reads the contents of a file and converts it to an integer:

\begin{rustc}
use std::fs::File;
use std::io::{self, Read};
use std::num;
use std::path::Path;

// We derive `Debug` because all types should probably derive `Debug`.
// This gives us a reasonable human readable description of `CliError` values.
#[derive(Debug)]
enum CliError {
    Io(io::Error),
    Parse(num::ParseIntError),
}

fn file_double_verbose<P: AsRef<Path>>(file_path: P) -> Result<i32, CliError> {
    let mut file = try!(File::open(file_path).map_err(CliError::Io));
    let mut contents = String::new();
    try!(file.read_to_string(&mut contents).map_err(CliError::Io));
    let n: i32 = try!(contents.trim().parse().map_err(CliError::Parse));
    Ok(2 * n)
}
\end{rustc}

Notice that we still have the calls to \code{map\_err}. Why? Well, recall the definitions of \code{try!} and \code{From}. 
The problem is that there is no \code{From} impl that allows us to convert from error types like \code{io::Error} and 
\code{num::ParseIntError} to our own custom \code{CliError}. Of course, it is easy to fix this! Since we defined 
\code{CliError}, we can impl \code{From} with it:

\begin{rustc}
use std::io;
use std::num;

impl From<io::Error> for CliError {
    fn from(err: io::Error) -> CliError {
        CliError::Io(err)
    }
}

impl From<num::ParseIntError> for CliError {
    fn from(err: num::ParseIntError) -> CliError {
        CliError::Parse(err)
    }
}
\end{rustc}

All these impls are doing is teaching \code{From} how to create a \code{CliError} from other error types. In our case, 
construction is as simple as invoking the corresponding value constructor. Indeed, it is typically this easy.

\blank

We can finally rewrite \code{file\_double}:

\begin{rustc}
use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double<P: AsRef<Path>>(file_path: P) -> Result<i32, CliError> {
    let mut file = try!(File::open(file_path));
    let mut contents = String::new();
    try!(file.read_to_string(&mut contents));
    let n: i32 = try!(contents.trim().parse());
    Ok(2 * n)
}
\end{rustc}

The only thing we did here was remove the calls to \code{map\_err}. They are no longer needed because the \code{try!} 
macro invokes \code{From::from} on the error value. This works because we've provided \code{From} impls for all the error 
types that could appear.

\blank

If we modified our \code{file\_double} function to perform some other operation, say, convert a string to a float, then 
we'd need to add a new variant to our error type:

\begin{rustc}
use std::io;
use std::num;

enum CliError {
    Io(io::Error),
    ParseInt(num::ParseIntError),
    ParseFloat(num::ParseFloatError),
}
\end{rustc}

And add a new \code{From} impl:

\begin{rustc}
use std::num;

impl From<num::ParseFloatError> for CliError {
    fn from(err: num::ParseFloatError) -> CliError {
        CliError::ParseFloat(err)
    }
}
\end{rustc}

And that's it!

\subsubsection*{Advice for library writers}

If your library needs to report custom errors, then you should probably define your own error type. It's up to you whether 
or not to expose its representation (like \href{https://doc.rust-lang.org/std/io/enum.ErrorKind.html}{ErrorKind}) or keep it 
hidden (like \href{https://doc.rust-lang.org/std/num/struct.ParseIntError.html}{ParseIntError}). Regardless of how you do it, 
it's usually good practice to at least provide some information about the error beyond its \String\ representation. But 
certainly, this will vary depending on use cases.

\blank

At a minimum, you should probably implement the \href{https://doc.rust-lang.org/std/error/trait.Error.html}{Error} trait. 
This will give users of your library some minimum flexibility for composing errors. Implementing the Error trait also means 
that users are guaranteed the ability to obtain a string representation of an error (because it requires impls for both 
\code{fmt::Debug} and \code{fmt::Display}).

\blank

Beyond that, it can also be useful to provide implementations of \code{From} on your error types. This allows you (the 
library author) and your users to compose more detailed errors. For example, 
\href{http://burntsushi.net/rustdoc/csv/enum.Error.html}{csv::Error} provides \code{From} impls for both \code{io::Error} 
and \code{byteorder::Error}.

\blank

Finally, depending on your tastes, you may also want to define a \result\ type alias, particularly if your library defines a 
single error type. This is used in the standard library for \href{https://doc.rust-lang.org/std/io/type.Result.html}{io::Result} 
and \href{https://doc.rust-lang.org/std/fmt/type.Result.html}{fmt::Result}.

\subsection*{Case study: A program to read population data}

This section was long, and depending on your background, it might be rather dense. While there is plenty of example code 
to go along with the prose, most of it was specifically designed to be pedagogical. So, we're going to do something new: a 
case study.

\blank

For this, we're going to build up a command line program that lets you query world population data. The objective is simple: 
you give it a location and it will tell you the population. Despite the simplicity, there is a lot that can go wrong!

\blank

The data we'll be using comes from the \href{https://github.com/petewarden/dstkdata}{Data Science Toolkit}. I've prepared 
some data from it for this exercise. You can either grab the 
\href{http://burntsushi.net/stuff/worldcitiespop.csv.gz}{world population data} (41MB gzip compressed, 145MB uncompressed) 
or only the \href{http://burntsushi.net/stuff/uscitiespop.csv.gz}{US population data} (2.2MB gzip compressed, 7.2MB uncompressed).

\blank

Up until now, we've kept the code limited to Rust's standard library. For a real task like this though, we'll want to at 
least use something to parse CSV data, parse the program arguments and decode that stuff into Rust types automatically. For 
that, we'll use the \href{https://crates.io/crates/csv}{csv}, and 
\href{https://crates.io/crates/rustc-serialize}{rustc-serialize} crates.

\subsubsection*{Initial setup}

We're not going to spend a lot of time on setting up a project with Cargo because it is already covered well in the Cargo section 
(see \nameref{sec:gettingstarted_helloCargo}) and \href{http://doc.crates.io/guide.html}{Cargo's documentation}.

\blank

To get started from scratch, run \code{cargo new --bin city-pop} and make sure your \code{Cargo.toml} looks something like this:

\begin{verbatim}
[package]
name = "city-pop"
version = "0.1.0"
authors = ["Andrew Gallant <jamslam@gmail.com>"]

[[bin]]
name = "city-pop"

[dependencies]
csv = "0.*"
rustc-serialize = "0.*"
getopts = "0.*"
\end{verbatim}

You should already be able to run:

\begin{verbatim}
cargo build --release
./target/release/city-pop
# Outputs: Hello, world!
\end{verbatim}

\subsubsection*{Argument parsing}

Let's get argument parsing out of the way. We won't go into too much detail on Getopts, but there is 
\href{http://doc.rust-lang.org/getopts/getopts/}{some good documentation} describing it. The short story is that Getopts 
generates an argument parser and a help message from a vector of options (The fact that it is a vector is hidden behind a 
struct and a set of methods). Once the parsing is done, we can decode the program arguments into a Rust struct. From there, 
we can get information about the flags, for instance, whether they were passed in, and what arguments they had. Here's our
 program with the appropriate \code{extern crate} statements, and the basic argument setup for Getopts:

\begin{rustc}
extern crate getopts;
extern crate rustc_serialize;

use getopts::Options;
use std::env;

fn print_usage(program: &str, opts: Options) {
    println!("{}", opts.usage(&format!("Usage: {} [options] <data-path> <city>", program)));
}

fn main() {
    let args: Vec<String> = env::args().collect();
    let program = args[0].clone();

    let mut opts = Options::new();
    opts.optflag("h", "help", "Show this usage message.");

    let matches = match opts.parse(&args[1..]) {
        Ok(m)  => { m }
        Err(e) => { panic!(e.to_string()) }
    };
    if matches.opt_present("h") {
        print_usage(&program, opts);
        return;
    }
    let data_path = args[1].clone();
    let city = args[2].clone();

    // Do stuff with information
}
\end{rustc}

First, we get a vector of the arguments passed into our program. We then store the first one, knowing that it is our 
program's name. Once that's done, we set up our argument flags, in this case a simplistic help message flag. Once we 
have the argument flags set up, we use \code{Options.parse} to parse the argument vector (starting from index one, because 
index 0 is the program name). If this was successful, we assign matches to the parsed object, if not, we panic. Once past 
that, we test if the user passed in the help flag, and if so print the usage message. The option help messages are constructed 
by Getopts, so all we have to do to print the usage message is tell it what we want it to print for the program name and 
template. If the user has not passed in the help flag, we assign the proper variables to their corresponding arguments.

\subsubsection*{Writing the logic}

We all write code differently, but error handling is usually the last thing we want to think about. This isn't great for 
the overall design of a program, but it can be useful for rapid prototyping. Because Rust forces us to be explicit about 
error handling (by making us call \code{unwrap}), it is easy to see which parts of our program can cause errors.

\blank

In this case study, the logic is really simple. All we need to do is parse the CSV data given to us and print out a field 
in matching rows. Let's do it. (Make sure to add \code{extern crate csv}; to the top of your file.)

\begin{rustc}
use std::fs::File;
use std::path::Path;

// This struct represents the data in each row of the CSV file.
// Type based decoding absolves us of a lot of the nitty gritty error
// handling, like parsing strings as integers or floats.
#[derive(Debug, RustcDecodable)]
struct Row {
    country: String,
    city: String,
    accent_city: String,
    region: String,

    // Not every row has data for the population, latitude or longitude!
    // So we express them as `Option` types, which admits the possibility of
    // absence. The CSV parser will fill in the correct value for us.
    population: Option<u64>,
    latitude: Option<f64>,
    longitude: Option<f64>,
}

fn print_usage(program: &str, opts: Options) {
    println!("{}", opts.usage(&format!("Usage: {} [options] <data-path> <city>", program)));
}

fn main() {
    let args: Vec<String> = env::args().collect();
    let program = args[0].clone();

    let mut opts = Options::new();
    opts.optflag("h", "help", "Show this usage message.");

    let matches = match opts.parse(&args[1..]) {
        Ok(m)  => { m }
        Err(e) => { panic!(e.to_string()) }
    };

    if matches.opt_present("h") {
        print_usage(&program, opts);
        return;
    }

    let data_file = args[1].clone();
    let data_path = Path::new(&data_file);
    let city = args[2].clone();

    let file = File::open(data_path).unwrap();
    let mut rdr = csv::Reader::from_reader(file);

    for row in rdr.decode::<Row>() {
        let row = row.unwrap();

        if row.city == city {
            println!("{}, {}: {:?}",
                row.city, row.country,
                row.population.expect("population count"));
        }
    }
}
\end{rustc}

Let's outline the errors. We can start with the obvious: the three places that \code{unwrap} is called:

\begin{enumerate}
  \item{\href{https://doc.rust-lang.org/std/fs/struct.File.html\#method.open}{File::open} can return an 
      \href{https://doc.rust-lang.org/std/io/struct.Error.html}{io::Error}.}
  \item{\href{http://burntsushi.net/rustdoc/csv/struct.Reader.html\#method.decode}{csv::Reader::decode} decodes one record at 
      a time, and \href{http://burntsushi.net/rustdoc/csv/struct.DecodedRecords.html}{decoding a record} (look at the 
      \code{Item} associated type on the \code{Iterator} impl) can produce a 
      \href{http://burntsushi.net/rustdoc/csv/enum.Error.html}{csv::Error}.}
  \item{If \code{row.population} is \none, then calling \code{expect} will panic.}
\end{enumerate}

Are there any others? What if we can't find a matching city? Tools like \code{grep} will return an error code, so we 
probably should too. So we have logic errors specific to our problem, IO errors and CSV parsing errors. We're going to 
explore two different ways to approach handling these errors.

\blank

I'd like to start with \code{Box<Error>}. Later, we'll see how defining our own error type can be useful.

\subsubsection*{Error handling with \code{Box<Error>}}

\code{Box<Error>} is nice because it \emph{just works}. You don't need to define your own error types and you don't need 
any \code{From} implementations. The downside is that since \code{Box<Error>} is a trait object, it erases the type, which 
means the compiler can no longer reason about its underlying type.

\blank

Previously we started refactoring our code by changing the type of our function from \code{T} to 
\code{Result<T, OurErrorType>}. In this case, \code{OurErrorType} is only \code{Box<Error>}. But what's \code{T}? And can we 
add a return type to \code{main}?

\blank

The answer to the second question is no, we can't. That means we'll need to write a new function. But what is \code{T}? 
The simplest thing we can do is to return a list of matching \code{Row} values as a \code{Vec<Row>}. (Better code would 
return an iterator, but that is left as an exercise to the reader.)

\blank

Let's refactor our code into its own function, but keep the calls to \code{unwrap}. Note that we opt to handle the 
possibility of a missing population count by simply ignoring that row.

\begin{rustc}
struct Row {
    // unchanged
}

struct PopulationCount {
    city: String,
    country: String,
    // This is no longer an `Option` because values of this type are only
    // constructed if they have a population count.
    count: u64,
}

fn print_usage(program: &str, opts: Options) {
    println!("{}", opts.usage(&format!("Usage: {} [options] <data-path> <city>", program)));
}

fn search<P: AsRef<Path>>(file_path: P, city: &str) -> Vec<PopulationCount> {
    let mut found = vec![];
    let file = File::open(file_path).unwrap();
    let mut rdr = csv::Reader::from_reader(file);
    for row in rdr.decode::<Row>() {
        let row = row.unwrap();
        match row.population {
            None => { } // skip it
            Some(count) => if row.city == city {
                found.push(PopulationCount {
                    city: row.city,
                    country: row.country,
                    count: count,
                });
            },
        }
    }
    found
}

fn main() {
    let args: Vec<String> = env::args().collect();
    let program = args[0].clone();

    let mut opts = Options::new();
    opts.optflag("h", "help", "Show this usage message.");

    let matches = match opts.parse(&args[1..]) {
        Ok(m)  => { m }
        Err(e) => { panic!(e.to_string()) }
    };
    if matches.opt_present("h") {
        print_usage(&program, opts);
        return;
    }

    let data_file = args[1].clone();
    let data_path = Path::new(&data_file);
    let city = args[2].clone();
    for pop in search(&data_path, &city) {
        println!("{}, {}: {:?}", pop.city, pop.country, pop.count);
    }
}
\end{rustc}

While we got rid of one use of \code{expect} (which is a nicer variant of \code{unwrap}), we still should handle the 
absence of any search results.

\blank

To convert this to proper error handling, we need to do the following:

\begin{enumerate}
  \item{Change the return type of \code{search} to be \code{Result<Vec<PopulationCount>, Box<Error>>}.}
  \item{Use the \code{try!} macro so that errors are returned to the caller instead of panicking the program.}
  \item{Handle the error in \code{main}.}
\end{enumerate}

Let's try it:

\begin{rustc}
use std::error::Error;

// The rest of the code before this is unchanged

fn search<P: AsRef<Path>>
         (file_path: P, city: &str)
         -> Result<Vec<PopulationCount>, Box<Error+Send+Sync>> {
    let mut found = vec![];
    let file = try!(File::open(file_path));
    let mut rdr = csv::Reader::from_reader(file);
    for row in rdr.decode::<Row>() {
        let row = try!(row);
        match row.population {
            None => { } // skip it
            Some(count) => if row.city == city {
                found.push(PopulationCount {
                    city: row.city,
                    country: row.country,
                    count: count,
                });
            },
        }
    }
    if found.is_empty() {
        Err(From::from("No matching cities with a population were found."))
    } else {
        Ok(found)
    }
}
\end{rustc}

Instead of \code{x.unwrap()}, we now have \code{try!(x)}. Since our function returns a \code{Result<T, E>}, the 
\code{try!} macro will return early from the function if an error occurs.

\blank

There is one big gotcha in this code: we used \code{Box<Error + Send + Sync>} instead of \code{Box<Error>}. We did this 
so we could convert a plain string to an error type. We need these extra bounds so that we can use the 
\href{https://doc.rust-lang.org/std/convert/trait.From.html}{corresponding From impls}:

\begin{rustc}
// We are making use of this impl in the code above, since we call `From::from`
// on a `&'static str`.
impl<'a, 'b> From<&'b str> for Box<Error + Send + Sync + 'a>

// But this is also useful when you need to allocate a new string for an
// error message, usually with `format!`.
impl From<String> for Box<Error + Send + Sync>
\end{rustc}

Since \code{search} now returns a \code{Result<T, E>}, main should use case analysis when calling search:

\begin{rustc}
...
match search(&data_file, &city) {
    Ok(pops) => {
        for pop in pops {
            println!("{}, {}: {:?}", pop.city, pop.country, pop.count);
        }
    }
    Err(err) => println!("{}", err)
}
...
\end{rustc}

Now that we've seen how to do proper error handling with \code{Box<Error>}, let's try a different approach with our own 
custom error type. But first, let's take a quick break from error handling and add support for reading from \code{stdin}.

\subsubsection*{Reading from \code{stdin}}

In our program, we accept a single file for input and do one pass over the data. This means we probably should be able to 
accept input on stdin. But maybe we like the current format tooâ€”so let's have both!

\blank

Adding support for stdin is actually quite easy. There are only three things we have to do:

\begin{enumerate}
  \item{Tweak the program arguments so that a single parameterâ€”the cityâ€”can be accepted while the population data is read 
      from stdin.}
  \item{Modify the program so that an option \code{-f} can take the file, if it is not passed into stdin.}
  \item{Modify the \code{search} function to take an \emph{optional} file path. When None, it should know to read from 
      stdin.}
\end{enumerate}

First, here's the new usage:

\begin{rustc}
fn print_usage(program: &str, opts: Options) {
    println!("{}", opts.usage(&format!("Usage: {} [options] <city>", program)));
}
\end{rustc}

The next part is going to be only a little harder:

\begin{rustc}
...
let mut opts = Options::new();
opts.optopt("f", "file", "Choose an input file, instead of using STDIN.", "NAME");
opts.optflag("h", "help", "Show this usage message.");
...
let file = matches.opt_str("f");
let data_file = file.as_ref().map(Path::new);

let city = if !matches.free.is_empty() {
    matches.free[0].clone()
} else {
    print_usage(&program, opts);
    return;
};

match search(&data_file, &city) {
    Ok(pops) => {
        for pop in pops {
            println!("{}, {}: {:?}", pop.city, pop.country, pop.count);
        }
    }
    Err(err) => println!("{}", err)
}
...
\end{rustc}

In this piece of code, we take \code{file} (which has the type \code{Option<String>}), and convert it to a type that 
\code{search} can use, in this case, \code{\&Option<AsRef<Path>>}. To do this, we take a reference of file, and map 
\code{Path::new} onto it. In this case, \code{as\_ref()} converts the \code{Option<String>} into an \code{Option<\&str>}, 
and from there, we can execute \code{Path::new} to the content of the optional, and return the optional of the new value. 
Once we have that, it is a simple matter of getting the \code{city} argument and executing \code{search}.

\blank

Modifying \code{search} is slightly trickier. The \code{csv} crate can build a parser out of 
\href{http://burntsushi.net/rustdoc/csv/struct.Reader.html\#method.from\_reader}{any type that implements io::Read}. But 
how can we use the same code over both types? There's actually a couple ways we could go about this. One way is to write 
\code{search} such that it is generic on some type parameter \code{R} that satisfies \code{io::Read}. Another way is to 
use trait objects:

\begin{rustc}
use std::io;

// The rest of the code before this is unchanged

fn search<P: AsRef<Path>>
         (file_path: &Option<P>, city: &str)
         -> Result<Vec<PopulationCount>, Box<Error+Send+Sync>> {
    let mut found = vec![];
    let input: Box<io::Read> = match *file_path {
        None => Box::new(io::stdin()),
        Some(ref file_path) => Box::new(try!(File::open(file_path))),
    };
    let mut rdr = csv::Reader::from_reader(input);
    // The rest remains unchanged!
}
\end{rustc}

\subsubsection*{Error handling with a custom type}

Previously, we learned how to compose errors using a custom error type. We did this by defining our error type as an 
\enum\ and implementing \code{Error} and \code{From}.

\blank

Since we have three distinct errors (IO, CSV parsing and not found), let's define an \enum\ with three variants:

\begin{rustc}
#[derive(Debug)]
enum CliError {
    Io(io::Error),
    Csv(csv::Error),
    NotFound,
}
\end{rustc}

And now for impls on \code{Display} and \code{Error}:

\begin{rustc}
impl fmt::Display for CliError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match *self {
            CliError::Io(ref err) => err.fmt(f),
            CliError::Csv(ref err) => err.fmt(f),
            CliError::NotFound => write!(f, "No matching cities with a \
                                             population were found."),
        }
    }
}

impl Error for CliError {
    fn description(&self) -> &str {
        match *self {
            CliError::Io(ref err) => err.description(),
            CliError::Csv(ref err) => err.description(),
            CliError::NotFound => "not found",
        }
    }
}
\end{rustc}

Before we can use our \code{CliError} type in our \code{search} function, we need to provide a couple \code{From} impls. 
How do we know which impls to provide? Well, we'll need to convert from both \code{io::Error} and \code{csv::Error} to 
\code{CliError}. Those are the only external errors, so we'll only need two \code{From} impls for now:

\begin{rustc}
impl From<io::Error> for CliError {
    fn from(err: io::Error) -> CliError {
        CliError::Io(err)
    }
}

impl From<csv::Error> for CliError {
    fn from(err: csv::Error) -> CliError {
        CliError::Csv(err)
    }
}
\end{rustc}

The \code{From} impls are important because of how \code{try!} is defined. In particular, if an error occurs, 
\code{From::from} is called on the error, which in this case, will convert it to our own error type \code{CliError}.

\blank

With the \code{From} impls done, we only need to make two small tweaks to our \code{search} function: the return type and 
the \enquote{not found} error. Here it is in full:

\begin{rustc}
fn search<P: AsRef<Path>>
         (file_path: &Option<P>, city: &str)
         -> Result<Vec<PopulationCount>, CliError> {
    let mut found = vec![];
    let input: Box<io::Read> = match *file_path {
        None => Box::new(io::stdin()),
        Some(ref file_path) => Box::new(try!(File::open(file_path))),
    };
    let mut rdr = csv::Reader::from_reader(input);
    for row in rdr.decode::<Row>() {
        let row = try!(row);
        match row.population {
            None => { } // skip it
            Some(count) => if row.city == city {
                found.push(PopulationCount {
                    city: row.city,
                    country: row.country,
                    count: count,
                });
            },
        }
    }
    if found.is_empty() {
        Err(CliError::NotFound)
    } else {
        Ok(found)
    }
}
\end{rustc}

No other changes are necessary.

\subsubsection*{Adding functionality}

Writing generic code is great, because generalizing stuff is cool, and it can then be useful later. But sometimes, the 
juice isn't worth the squeeze. Look at what we just did in the previous step:

\begin{enumerate}
  \item{Defined a new error type.}
  \item{Added impls for \code{Error}, \code{Display} and two for \code{From}.}
\end{enumerate}

The big downside here is that our program didn't improve a whole lot. There is quite a bit of overhead to representing 
errors with \enum s, especially in short programs like this.

\blank

One useful aspect of using a custom error type like we've done here is that the \code{main} function can now choose to 
handle errors differently. Previously, with \code{Box<Error>}, it didn't have much of a choice: just print the message. 
We're still doing that here, but what if we wanted to, say, add a \code{--quiet} flag? The \code{--quiet} flag should 
silence any verbose output.

\blank

Right now, if the program doesn't find a match, it will output a message saying so. This can be a little clumsy, especially 
if you intend for the program to be used in shell scripts.

\blank

So let's start by adding the flags. Like before, we need to tweak the usage string and add a flag to the Option variable. 
Once we've done that, Getopts does the rest:

\begin{rustc}
...
let mut opts = Options::new();
opts.optopt("f", "file", "Choose an input file, instead of using STDIN.", "NAME");
opts.optflag("h", "help", "Show this usage message.");
opts.optflag("q", "quiet", "Silences errors and warnings.");
...
\end{rustc}

Now we only need to implement our \enquote{quiet} functionality. This requires us to tweak the case analysis in \code{main}:

\begin{rustc}
match search(&args.arg_data_path, &args.arg_city) {
    Err(CliError::NotFound) if args.flag_quiet => process::exit(1),
    Err(err) => panic!("{}", err),
    Ok(pops) => for pop in pops {
        println!("{}, {}: {:?}", pop.city, pop.country, pop.count);
    }
}
\end{rustc}

Certainly, we don't want to be quiet if there was an IO error or if the data failed to parse. Therefore, we use case 
analysis to check if the error type is \code{NotFound} \emph{and} if \code{--quiet} has been enabled. If the search failed, 
we still quit with an exit code (following \code{grep}'s convention).

\blank

If we had stuck with \code{Box<Error>}, then it would be pretty tricky to implement the \code{--quiet} functionality.

\blank

This pretty much sums up our case study. From here, you should be ready to go out into the world and write your own 
programs and libraries with proper error handling.

\subsection*{The Short Story}

Since this section is long, it is useful to have a quick summary for error handling in Rust. These are some good 
\enquote{rules of thumb.} They are emphatically not commandments. There are probably good reasons to break every one 
of these heuristics!

\begin{itemize}
  \item{If you're writing short example code that would be overburdened by error handling, it's probably fine to use 
      \code{unwrap} (whether that's \href{https://doc.rust-lang.org/std/result/enum.Result.html\#method.unwrap}{Result::unwrap}, 
      \href{https://doc.rust-lang.org/std/option/enum.Option.html\#method.unwrap}{Option::unwrap} or preferably 
      \href{https://doc.rust-lang.org/std/option/enum.Option.html\#method.expect}{Option::expect}). Consumers of your code 
      should know to use proper error handling. (If they don't, send them here!)}
  \item{If you're writing a quick 'n' dirty program, don't feel ashamed if you use \code{unwrap}. Be warned: if it winds 
      up in someone else's hands, don't be surprised if they are agitated by poor error messages!}
  \item{If you're writing a quick 'n' dirty program and feel ashamed about panicking anyway, then use either a \String\ or 
      a \code{Box<Error + Send + Sync>} for your error type (the \code{Box<Error + Send + Sync>} type is because of the 
      available \code{From} impls).}
  \item{Otherwise, in a program, define your own error types with appropriate 
      \href{https://doc.rust-lang.org/std/convert/trait.From.html}{From} and 
      \href{https://doc.rust-lang.org/std/error/trait.Error.html}{Error} impls to make the 
      \href{https://doc.rust-lang.org/std/macro.try!.html}{try!} macro more ergonomic.}
  \item{If you're writing a library and your code can produce errors, define your own error type and implement the 
      \href{https://doc.rust-lang.org/std/error/trait.Error.html}{std::error::Error} trait. Where appropriate, implement 
      \href{https://doc.rust-lang.org/std/convert/trait.From.html}{From} to make both your library code and the caller's 
      code easier to write. (Because of Rust's coherence rules, callers will not be able to impl \code{From} on your error 
      type, so your library should do it.)}
  \item{Learn the combinators defined on \href{https://doc.rust-lang.org/std/option/enum.Option.html}{Option} and 
      \href{https://doc.rust-lang.org/std/result/enum.Result.html}{Result}. Using them exclusively can be a bit tiring at 
      times, but I've personally found a healthy mix of \code{try!} and combinators to be quite appealing. \code{and\_then}, 
      \code{map} and \code{unwrap\_or} are my favorites.}
\end{itemize}
